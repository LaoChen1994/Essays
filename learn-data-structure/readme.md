# 数据结构与算法图解

## 第一章 数据结构为何重要

**操作的速度（时间复杂度）：**指的是程序运行的步数，具体的执行时间由机器决定

### 1.1 基础数据结构：数组

数组的结构： [1, 2, 3, 4]

基本操作：读取，查找，插入删除

##### 1.1.1 读取

读取是通过引用直接找到对应的内存地址中的数据值，这种一步是最快的速度，可以理解为复杂度就是1

##### 1.1.2 查找

查找的复杂度和数组的长度有关，如果长度为5的数组复杂度就为5，所以推到长度为N的数组，复杂度就为N

##### 1.1.3 插入

插入的时候需要分为两步：

1. 后续所有商品的向后移一个位置（最复杂情况，第一个元素插入，长度为N的数组需要操作N步） 
2. 插入新元素（1步）

**总计的复杂度：N+1**

##### 1.1.4 删除

删除是插入的逆操作，分为两步：

1. 删除对应的元素（1步）
2. 将后续的所有节点元素左移（N - 1步）

**总计的复杂度：N**



### 1.2 集合：一条规则决定性能

这里的集合指的是类似js中的Set

集合的结构（python）：（1, 2, 3, 4）

基本的操作：读取，查找，插入删除

##### 1.2.1 读取

和数组一样，读取都是直接拿到对应地址中的值，复杂度为1

##### 1.2.2 查找

和数组一样，为N

##### 1.2.3 插入

集合的插入步骤为三步：

1. 查找是否重复（N）
2. 对应位置后的元素都向后移动一个位置，最差（N-1）
3. 插入（1）

**总计：2N**

##### 1.2.4 删除

和数组一样，为N



### 1.3 总结

主要讲了时间复杂度的计算方法，至于后续怎么分析对应的时间复杂度来服务自己写出高性能的代码，需要我们自己选择



## 2. 算法为何重要

算法是什么？为了达到某种目的，执行某种操作的操作流程

算法有啥用？可以决定程序的运行速度

### 2.1 有序数组

以数组为例：[3, 17, 80, 202]

#####  2.1.1 插入步骤

1. 先查找对应插入的位置（一个一个位置对比）
2. 后面元素向后移动
3. 插入

##### 2.1.2 查找步骤

线性查找：从头到位遍历逐一进行对比，因为是有序的，所以一般来说有序数组的查找步骤会少于无序数组

从线性查找来看，两种数据类型查找没有拉开差距，但是当用了其他算法之后，可能性能上就会拉开差距（二分查找）



### 2.2 二分查找

思想：如果是有序数组，先找一半大小的索引值，然后判断目标索引在左侧还是右侧，然后对剩下的部分再进行二分查找

```javascript
// 原文是ruby实现的，这里通过js实现
function bindSearch(array, target) {
  let lowBound = 0
  let highBound = array.length
  let targetIndex = -1

  while (lowBound < highBound) {
    const middleIndex = Math.floor((lowBound + highBound) / 2)

    if (array[middleIndex] === target) {
      targetIndex = middleIndex
      break
    } else if (array[middleIndex] < target) {
      // 不存在的时候只剩最接近的一位，不做这个判断会永远卡在这里死循环了
      if (lowBound === middleIndex) break
      lowBound = middleIndex
    } else {
      highBound = middleIndex
    }
  }

  return targetIndex
}
```



### 2.3 二分查找的优势

有序数组的场景下：

线性查找：最坏复杂度为N，因为需要遍历整个数组，比最后一位还要大的话，就会是N

二分查找：数组的长度每翻一倍，步骤 + 1（log~2~N）



## 3. 大O记法

通过大O计数法，来描述算法的性能级别，来表达数据结构和算法的复杂度

### 3.1 数步法

| 复杂度  | 大O表示 | 解释                           |
| ------- | ------- | ------------------------------ |
| 1数量级 | O(1)    | 一步的操作，例如数组的读取     |
| N数量级 | O(N)    | 对于N个元素，其操作步骤需要N次 |

### 3.2 常数时间和线性时间

常数复杂度：代表随着数据量增长，固定不变的复杂度，例如值的读取

线性复杂度：代表执行步骤随着数据量的增长，线性变化的复杂度

### 3.3 同一算法，不同场景

对于同一算法来说，如果没有特别指出，大O记法一般都是指算法的**最坏情况**

### 3.4 第三种算法

| 复杂度  | 描述                                        | 备注                                           |
| ------- | ------------------------------------------- | ---------------------------------------------- |
| O(N)    | 每增加一个元素，复杂度需要增加1，线性复杂度 | 代表执行步骤随着数据量的增长，线性变化的复杂度 |
| O(1)    | 不管如何增加元素，复杂度都为1，常数复杂度   | 代表随着数据量增长，固定不变的复杂度           |
| O(LogN) | 当数据量翻倍时，复杂度+1                    | 对数复杂度，介于O(1)与O(N)之间                 |

### 总结

主要就是讲了什么是O(N), O(1), O(logN)的大O记法的区别和怎么计算一个算法的复杂度



