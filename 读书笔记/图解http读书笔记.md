# 图解http

## 1. 了解web及网络基础

## 1.1 使用HTTP协议访问Web

略

## 1.2 HTTP的诞生

略

## 1.3 网络基础TCP/IP

TCP/IP协议族：从电缆的规格到IP地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及Web页面显示需要处理的步骤把这些和互联网通信相关的协议统称为TCP/IP协议族

网络分层：

+ 应用层（会话、表示、应用）：预存了各类应用，包含（FTP、DNS、HTTP）
+ 传输层：提供网络间两台计算机之间的数据传输，包含TCP和UDP
+ 网络层：网络层用来处理在网络上流动的数据包。    
+ 数据链路层：用来处理连接网络的硬件部分
+ 物理层：处理MAC地址等

A -> B发送数据，则数据包从应用层一层一层向下==封装==成对应层的数据包，最终通过数据链路层和物理层发送到B，B从物理层接收到包后，一层一层向上==解包==

## 1.4 与HTTP关系密切的协议：IP、TCP和DNS

### 1.4.1 负责传输的IP协议

位置：网络层

名称：网际协议

作用：把各种数据包传送给对方

几个阶段：

1. IP协议先通过ARP协议来根据目的地的IP反查MAC地址，来进行MAC地址的通信  

> ARP协议: 根据通信方的IP地址就可以反查出对应的MAC地址，使用场景就是如果A -> B -> C, A要访问C但是其实可能需要通过B进行中转，这个时候B要到C其实是通过ARP通过C的IP来查C的MAC地址来转接到C的。

2. 路由选择：就是A -> C可能中间通过了B D的转发，也可能没有，根据网络情况而定，这个是没有统一的规则的。


**注意：**

1. IP协议和IP地址还是有区别，**IP协议的作用是把各种数据包传送给对方**。而要保证确实传送到对方那里，则需要满足各类条件。其中**两个重要的条件是IP地址和MAC地址**。

2. MAC地址基本不变，IP可能会变。

### 1.4.2 确保可靠性的TCP协议

位置：传输层

作用：提供可靠的字节流服务

> 字节流：将大量的数据信息切成小的报文，然后分批发送

> 可靠：能够准备的把信息传送给对方（三次握手、四次挥手）

三次握手如何保证可靠：SYNC和ACK的确认标识位 

### 1.5 负责域名解析的DNS服务

DNS做的事情：将域名（字母化，语义化的链接）转换为实际的IP地址

权限有域名的服务器访问：

1. 浏览器 访问 域名
2. 先去通过DNS服务器查询域名对于的IP
3. 查询到IP之后再去访问对应的IP地址对应的服务器

### 1.6各种协议与HTTP协议的关系

**发送端：**
HTTP: 生成针对Web的HTTP报文
TCP：将生成的HTTP报文分成多个报文段
IP协议：搜索对方的地址（ARP），并一边中转一边发送

**接收端**
TCP：接收端按照顺序进行报文重组
HTTP：处理Web请求的内容进行处理

### 1.7 URL和URI

#### 1.7.1 定义：

> 与URI（统一资源标识符）相比，我们更熟悉URL（Uniform Resource Locator，统一资源定位符）。URL正是使用Web浏览器等访问Web页面时需要输入的网页地址

**URL: **就是我们说的网页地址

**URI？**

Uniform： 统一规定的格式（协议）来处理各种资源：http或ftp等

Resource：资源，例如图片文档等可以标识的任何东西

Identifier：标识符

#### 1.7.2 URI格式

协议名 + 登陆信息（可选） + 服务器地址（IP或域名） + 端口号 + 文件路径 + 查询字符串


**自己理解**：

URL和URI之间的区别：URL是一个定位符，定位到一个资源，但是URI其实是一个标准，他可以表示一个资源域，也可以是一个单一的资源

## 2. 简单的HTTP协议

### 2.1 HTTP协议用于客户端和服务器端之间的通信

HTTP协议作为TCP/IP协议族中的一员也是来保证客户端和服务端之间通信用的。

在网络中通信一定一端是**客户端**，一端是**服务端**，HTTP协议就是用来区分谁是客户端谁是服务端的。

### 2.2 通过请求和响应的交换达成通信

1. HTTP协议是从客户端发出，在服务端被解析的
2. 标准HTTP报文的组成:
   请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。
   ```http
   GET /index.html HTTP/1.1
   Host: hackr.jp
   Conection: keep-alive
   Content-Type: application/x-www-form-urlencoded
   Content-Length: 16
   // 内容
   name=url
   ```

3. 服务器相应的请求
   包含几个部分：协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。

   ```http
    Request URL: https://www.google-analytics.com/j/collect?xxxx
    Request Method: POST
    Status Code: 200 OK
    Remote Address: 127.0.0.1:8001
    Referrer Policy: strict-origin-when-cross-origin
   ```

### 2.3 HTTP协议是无状态的协议

HTTP本身是无状态的协议，即协议对发送过的请求或协议都不做持久化处理。（便于更快的处理大量请求）

正因为HTTP是无状态的协议，当业务需要持久化的时候，这样的协议处理起来就比较棘手了，因此，引入了cookie，通过cookie来保证状态的持久化。

### 2.4 通过URI定位资源

HTTP利用URI来定位指定的资源，通过URI本身的功能，能够定位到指定的资源。

URI请求的方式有多种：

1. URI为完整的请求
2. 在HOST中写明网络域名或IP地址，在请求的方式后面接的是资源的路径
3. 如果不是访问特定资源而是对服务器本身发起请求，可以用*来URI，直接访问服务器
   ```http
   OPTIONS * HTTP/1.1
   ```
### 2.5 告知服务器意图的HTTP方法

+ HTTP 1.1中的可使用的方法：
    + GET：请求访问已被URI识别的资源，如果是文本资源就原样返回，如果是接口就执行后返回对应的数据，主要是为了获取响应的主体信息。
    + POST：用来发送请求实体的主体信息（主要是客户端将实体的信息传输给服务端），一般POST不是为了获取响应的主体内容。
    + PUT：传输文件，要求在请求报文主体中包含文件内容，但是HTTP/1.1中其实不会对上传文件进行安全校验，因此不会开放这个请求方法，有些用REST接口的可能会开放这个方法应用于更新
    + HEAD：和GET请求一样，但是不返回响应主体，只返回响应头
    + DELETE：删除文件，用于删除指定URI对应的资源
    + OPTIONS：用于查询对指定的URI请求支持的方法。（相应的请求会返回Allow：xxxx来告诉浏览器这个资源支持请求的方法）
    + TRACE：让web服务器将之前的请求通信环回给客户端的方法（简单理解就是：发送请求的时候将头中的Max-Forwards填入一个数值，然后每过一个服务器这个数字就会-1，等到数值刚好减到0的时候，就停止继续传输，然后对应的服务器返回200 OK的状态码），客户端可以通过TRACE请求来研究该请求是怎么被篡改的，容易造成XST攻击，不会被用到。
    + CONNECT：在与代理服务器通信时用到，实现用隧道协议完成TCP/SSL请求。主要使用SSL和TLS协议，把通信内容加密后经网络隧道进行传输。

### 2.6 使用方法下达命令

通过2.5中的方法向指定的URI发送报文的时候，服务器会做出对应的操作

### 2.7 持久连接节省通信量

1. 为什么要持久链接？
   因为当一个页面友大量的请求的时候，之前HTTP是每一个请求就需要“三次握手，四次挥手”，完成对重新的TCP链接和断开连接，这样是非常低效且浪费资源的。

2. 持久连接（keep-alive）
   优点：只要一边没有提出断开连接，连接通道会一直保留。不会每一个请求就需要重新建立TCP连接，减少了额外的开销

3. 管线化
   持久连接使得管线化成为可能。管线化就是 -> 多个请求同步并行发送，不需要一个接一个的等待了。

### 2.8 使用Cookie来完成状态管理

因为HTTP是一个无状态协议，请求就是无状态的请求，如果通过将对应的登陆信息，通过请求带过去，那无疑会造成安全问题。

为了解决HTTP无状态的问题引入了cookie，通过在请求和响应报文中写入cookie来控制客户端的登陆状态。

**Cookie的写入**：
客户端根据响应头中带来的Set-Cookie首部字段信息来通知客户端保存Cookie，在客户端下次往服务端发送请求的时候，就会带上这个cookie的信息，服务端接受到客户端带来的信息之后，对比服务器上的记录（token解密等），得到之前的状态信息。

```javascript

// 如果没有带上cookie，响应头中会带上这个
Set-Cookie: sid=xxxxxxx

```

```javascript
// 在有了cookie，下次请求头中会通过cookie字段带过去
Cookie: sid=xxxxx

```

## 3. HTTP报文内的HTTP信息

### 3.1 HTTP报文

按照类型来分：**响应报文** 和 **请求报文**

按照内容来分：**报文首部** 和 **报文主体**

报文首部和报文主体之间是通过：CR + LF

一般来说报文主体可以为空，例子就是可以搞一个没有参数的post请求

### 3.2 请求报文及响应报文的结构


1. 请求报文对应的内容如下：
   + 请求行：包括请求的方法、URI和HTTP版本
   + 请求首部字段     --｜
   + 请求通用首部字段 --｜-> 包含了请求中的各种条件和属性
   + 请求实体首部字段 --｜
   + 其他


2. 响应报文的内容如下：
   + 状态行：包括相应的状态码、理由短语、HTTP版本
   + 响应首部字段--|
   + 通用首部字段--|-> 包含了响应中的各种条件和属性。
   + 实体首部字段--|
   + 其他：一些其他的扩展信息，在HTTP RFC中未定义的字段，例如Cookie相关的部分

### 3.3 编码提升传输速率

#### 3.3.1 为什么要编码？

通过编码可以极大的提升传输的效率，但是可能需要客户端进行编码，因此会消耗更多的CPU资源

#### 3.3.2 报文主体和实体之间的差异

报文：指的是HTTP传输中的基本单位，由8位的字节流组成，理解就是 -> 我们要发送的内容他就是报文的内容

实体：就是最后在HTTP请求和相应过程中承载报文的信息。实体 = 实体首部 + 实体主体，其实体主体在报文不进行编码的情况下等于报文主体。

#### 3.3.3 内容编码，实现压缩传输

通过内容编码，将内容进行压缩，提升传输的效率

内容编码后的实体，**通过客户端进行解码，获得相应的报文主体**

内容编码的方法：

+ gzip (GUN zip)
+ compress (unix的编码规则)
+ deflate (zlib)
+ identity (不进行编码)

#### 3.3.4 分割发送，分快传输编码

在浏览器端，只有当内容都被传输完后才会展示页面，这个时候如果其中某一部分的资源很大，就非常的影响首屏体验了，因此，在传输大容量的数据的时候，先将数据切分成多个小块，能让浏览器逐步展示页面

这种把实体主体分为多个小块的编码方式叫做：分块编码。

> 每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标记。然后在客户端解析的时候还原为原来的实体

### 3.4 发送多种数据的多部分对象集合

**多部分集合**：指的是一份发送的实体中有多种类型的数据，例如图片 + 文字 + 其他类型的文件。

这种多类型的文件传输是采用了**MIME机制**来进行处理的。

在MIME中，会使用一种称为多部分对象集合（Multipart）的方法，来容纳多份不同类型的数据。

Multipart包括哪些类型，Content-Type：
+ multipart/form-data： 表单
+ multipart/byteranges：206状态码的时候，只包括一部分的报文内容，其中boundary用来划分各个部分的对象集合指明的实体内容，其中用**--xxx**来标记实体的起始位置，然后在最后插入**--**标志作为一个部分的结束（在实体的body中）

### 3.5 获取部分内容的范围请求

场景：比如一个文件一共10000字节，下载到5000的时候断开了链接，继续回来下载的时候其实只需要下载5001～10000字节即可。

使用方法：
1. 请求头中添加Range: 5001-10000
2. 情头时候的Content-Type需要设置为multipart/byteranges

响应：
1. 响应的Content-Type这个时候是请求资源的类型
2. Content-Range：bytes 5001-10000/10000 
3. Content-Length: 5000
4. 状态码206

实现了部分的请求，通过在请求头中添加Range和Content-Type即可做到。

**注意点：Range的写法**

1. 指定长度：Range: 5001-10000
2. 某个片段到尾部：Range: 5001-
3. 多个区间：Range: -3000,5000-

当然如果服务器本身无法响应范围请求，就会返回200，并且返回全部的请求

### 3.6 内容协商请求

#### 3.6.1 什么是内容协商

内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。

例如,一个网站同时有中文和英文版，希望中国的用户在访问的时候展示中文版。这就是一种协商的机制

#### 3.6.2 如何协商

内容协商主要是通过请求报文中给的一些字段进行分析，然后以响应的资源做出回应。

包含在请求报文中的某些首部字段（如下）就是判断的基准：
+ Accept
+ Accept-Charset
+ Accept-Encoding
+ Accept-Language
+ Content-Language

#### 3.6.3 内容协商技术的类型
1. 服务器驱动协商：
   解释：服务器根据客户端请求给予的一些基准，自动处理协商的内容，返回对应的资源。
   问题：客户端发送的请求不一定就是用户想要的，匹配精准度不够

2. 客户端驱动协商：
   解释：用户从浏览器显示的可选项列表中手动选择，即让用户自己手动切换
   
3. 透明协商
   解释：就是服务器先根据请求进行判断给一个初始方案，但是客户端也可供用户进行选择



### 4. 返回结果的HTTP状态码

#### 4.1 状态码告知从服务器端返回的请求结果

状态码的职责：当客户端向服务器端发送请求时，告知客户端请求处理的结果。

状态码的类型：

+ 1xx: 接受的请求正在处理中
+ 2xx: 请求正常处理完毕
+ 3xx: 重定向状态码，需要进行附加操作完成请求（浏览器侧）
+ 4xx: 服务器无法处理请求，客户端错误
+ 5xx：服务器请求处理出错

#### 4.2 2XX成功

**200**: 表明请求再服务端呗正常处理
**204**: 表明请求呗正常处理成功，但返回的相应报文中不包含任何实体的主体。（人话：请求我处理了，但是没东西返回）
**206**: 这是一个Partial的请求，就是有Content-Range的部分，会返回对应的Content-Range的内容

#### 4.3 3XX重定向

**301**: 永久重定向。该状态码表示请求的资源已经被分配了新的URI，后续应该使用该资源新的URI
**302**：临时重定向。和301的区别是是否在用户比如添加到书签的时候，用新的URI进行保存
**303**: 资源存在另外一个URI可以表示，应该使用GET方法来获取
**304**: 资源已经找到且服务器支持请求，但是由于部分header带的不对，未满足要求所以没有请求成功
**307**: 临时重定向，和302的区别是浏览器强制不能由POST请求转GET

**注意点**：
1. 当301、302、303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。
2. 304中的header中的附加条件信息包括If-Match, If-Modified-Since, If-None-Match, If-Range等

#### 4.4 4XX客户端错误

**400**: 表示请求报文中有参数错误，一般前端参数传错了
**401**: 表示需要通过HTTP认证，当前没有授权，之后需要带一个Authorization Token
**403**：访问被服务端拒绝，权限验证失败，或者文件系统有问题等
**404**：无法找到对应的资源


#### 4.5 5XX服务器错误

**500**: 内部服务器错误，可能是Web应用的bug
**503**：服务器不可用，比如停机或者正在维护

### 5. 与HTTP协作的Web服务器

#### 5.1 用单台虚拟主机实现多个域名

通过虚拟主机可以寄存多个不同的主机名和域名的Web网站，因为通过DNS对物理主机进行访问的时候就是通过IP进行访问，因此如果一台物理服务器需要识别出具体是访问哪个虚拟主机托管的域名，需要在HOST首部指定完整的主机名和域名

#### 5.2 通信数据转发程序：代理、网关、隧道

##### 5.2.1 代理：

具有**转发功能**的**应用程序**，转发服务器的响应和客户端的请求，理解房屋中介

代理可以多级级联，层层转发，通过Via首部来记录经过的主机信息，一般代理不会修改原URI请求，会直接发送给对方的目标资源请求服务器

代理的方法：1. 是否使用缓存 2. 是否修改报文

缓存代理：代理服务器会把请求资源的缓存到代理服务器上，下次请求相同的资源，直接从缓存里拿

透明代理：转发请求和响应时不做任何加工的代理类型

##### 5.2.2 网关
**网关**：转发其他服务器的通信数据的**服务器**，当客户端访问到网关服务器的时候，网关服务器也像拥有自己资源的源服务器一样进行请求的处理

网关机制和代理类似，不同的是因为网关是自己的服务器，他可以支持在通信链路上以非HTTP协议的方式传播，比如和数据库，redis链接这类的。

##### 5.2.3 隧道：

**隧道**：在服务器和客户端之间建立的保持双方通信的应用程序

隧道本身是透明的，建立一个客户端和服务器之间的通信链路，之后通过SSL等手段进行加密，确保服务器和客户端之间进行安全的通信，本身是不会去解析http协议的

#### 5.3 保存资源的缓存

缓存服务器的优势就是避免多次从源服务器转发资源，因此客户端就可以就近缓存获取资源，而源服务器也不必多次处理想通的请求了

##### 5.3.1 缓存的有效期

缓存会有一个缓存时间，如果过期了就会继续向源服务器请求，获取新的资源并缓存

##### 5.3.2 客户端的缓存

浏览器也会有浏览器的缓存，如果命中了浏览器缓存就和缓存服务器一样，会先用缓存服务器中的数据，若浏览器缓存失效就会向源服务器发送对应的请求。

浏览器的缓存分为：**强制缓存**和**协商缓存**

**本地缓存**：一个资源如果浏览器本地缓存命中了强制缓存就会直接使用该本地资源，不会发送请求到服务端

**协商缓存**：浏览器发送请求，从Request Header中带过去的信息判断是否命中协商缓存，命中了服务器会304并在请求体里不带任何的资源信息，然后告诉浏览器，可以命中哪个缓存拿对应的资源

![image-20210904123741467](/Users/pidan/Library/Application Support/typora-user-images/image-20210904123741467.png)

##### 5.3.3 其他协议的介绍

1. FTP：文件传输协议
2. NNTP：用于NetNews传递的协议
3. Archie：搜索匿名FTP公开文件的协议
4. WAIS：关键词数据库检索协议
5. Gopher：查找互联网内连接的计算机信息的协议

### 6. HTTP首部

HTTP报文 = 报文首部 + 报文主体

#### 6.1 HTTP报文首部

请求报文首部 = 请求行（请求方法 + URI + HTTP版本） + (请求首部字段 + 通用首部 + 实体首部) -> http首部字段

响应报文首部 = 状态行（http版本、状态码） + （响应首部字段 + 通用首部字段 + 实体首部字段）-> HTTP首部字段

#### 6.2 HTTP首部字段

##### 6.2.1 HTTP首部传递的信息

主要是向服务器和浏览器传递请求过程中的额外信息用的

> 使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。

##### 6.2.2 HTTP首部字段结构

**首部字段结构**

> 首部字段名: 字段值
> 例如 Content-Type: text/html
> Keep-Alive: timeout=15, max=100

注意：如果一个请求头中有2个以上的相同的请求头属性，其具体的处理方式在规范中未定义

##### 6.2.3 4种HTTP首部字段类型

略

##### 6.2.4 HTTP/1.1 首部字段一览

后面在每个首部介绍的时候会逐一介绍，这里就不列表了
略

##### 6.2.6 端到端首部和逐跳首部

逐跳首部：

1. Connection
2. Keep-Alive
3. Proxy-Authenticate
4. Proxy-Authorization
5. Trailer
6. TE
7. Transfer-Encoding
8. Upgrade


#### 6.3 HTTP/1.1通用部首字段

一般是 部首字段名：字段值

字段值中多个指令通过，进行分割

##### 6.3.1 Cache-Control

作用：用于操作工作缓存机制

指令列表：

| 请求指令        | 参数   | 说明                                                         |
| --------------- | ------ | ------------------------------------------------------------ |
| no-cache        | /      | 不使用缓存                                                   |
| no-store        | /      | 不缓存任何请求                                               |
| max-age=[秒]    | 必须   | 缓存的最大时间                                               |
| max-stale=[秒]  | 非必需 | 接受已过期的响应                                             |
| min-fresh=[秒]  | 必需   | 期望在一定时间内还有效（告诉缓存服务器，这段时间[min-fresh]时间内的过期的资源都不要从缓存里面给我了） |
| no-transform    | 无     | 代理不改变媒体类型资源的类型（防止图片压缩缓存）             |
| only-if-cache   | 无     | 从缓存获取资源                                               |
| cache-extension | 无     | 新指令标记                                                   |

| 响应指令         | 参数               | 说明                                                         |
| ---------------- | ------------------ | ------------------------------------------------------------ |
| public           | /                  | 可向方向提供响应缓存                                         |
| private          | /                  | 指向对应的用户私有化使用缓存信息                             |
| no-cache         | 可省略，location等 | 缓存前判断，是否有效的资源（为了防止浏览器缓存已经失效的资源） |
| no-store         | /                  | 不缓存资源（一般是一些机密信息，不需要缓存）                 |
| no-transform     | /                  | 媒体资源不需要转换格式                                       |
| must-revalidate  | /                  | 可缓存资源但是需要和服务器进行确认                           |
| proxy-revalidate | /                  | 需要缓存代理服务器对缓存资源进行验证                         |
| max-age=[秒]     | 必须               | 有效期限                                                     |
| s-maxage=[秒]    | 必须               | public的资源对应的有效时间（对于公用的场合来说）             |
| cache-extension  | 无                 | 新指令标记                                                   |

##### 6.3.2 Connection

作用：
1. 控制不再转发给代理的首部字段
2. 管理持久连接

**控制不再转发给代理的手部字段**

> Connection: Upgrade

在代理服务器接到请求，且带有上述的Connection的时候，在下一跳转发的时候，会把Upgrade请求头给过滤掉再发给下一跳的请求。

**管理持久连接**

通过Connection的Keep-Alive和close指令来控制是否连接应该结束。

##### 6.3.3 Date

用来表明报文创建的日期和时间

##### 6.3.4 Pragma

主要是HTTP1.0 时候向后兼容的字段，范定义的形式唯一

> Pragma: no-cache

在HTTP1.1的场景下和Cache-Control: no-cache的作用是一样的

##### 6.3.5 Trailer

一般的报文都是 报文首部 + 报文主体

但是可能会有报文部分首部 + 报文主体 + 报文部分首部

这个Trailer就是用来标记在报文主体之后还有哪些报文首部的

##### 6.3.6 Transfer-Encoding

用于告诉报文传递的方式，一般都是chunked，标明是分块传输的。

##### 6.3.7 Upgrade

用于检测HTTP以及其他协议是否由更高可用的版本，如果又了Upgrade字段需要，通过Connection将下一级的Upgrade字段进行去除，因为到下一阶段就已经是使用新的更高的协议了

对于由Upgrade字段的请求，响应状态可以是101

##### 6.3.8 Via

为了追踪客户端和服务器之间的相应和请求的报文传输路径

报文经过网关或者代理的时候会在Via字段中添加该服务器的信息，然后进行转发。

通过Via这个字段不仅可以记录对应的路径信息，还能避免请求回环的发生，必须在经过代理时附加改字段头

一般通过Trace和Max-Forwards来记录整个链路经过多少个代理和网关，来检测恶意转发的问题

##### 6.3.9 Warning

主要是提供一些和**缓存相关的**警告信息

110: 代理返回已过期的资源
111：代理验证资源时效性失败
112：代理与互联网连接被切断
113：响应使用期超过24小时
199：任意的警告内容
214：代理对编码内容做了处理
299：任意的告警

### 6.4 请求首部字段

作用：用于补充请求的附加信息、客户端信息、响应内容相关的优先级信息。

| 字段名              | 字段类型 | 作用                                                         | 备注                                                         |
| ------------------- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Accept              | string   | 用于告知服务器需要接受什么样的资源，主流的媒体类型           | 主流的媒体类型：<br />1. 文本文件：text/html, text/css, text/plain, application/javascript <br />2. 图片文件：image/jpeg, image/gif, image/png <br />3. 视频文件：video/mpeg, video/quicktime <br />4. 应用程序的二进制文件：application/octet-stream等<br />权重的设定：<br />type/subtype是类型标志，多个类型标志之间通过==，==进行分割，然后通过==;==来指定相应的属性，比如优先级q(0 < q <= 1).比如text/html, text/plain;q=0.8 |
| Accept-Charset      | string   | 告知服务器代理客户端可以用来处理的字符集的优先顺序           | 属于内容协商机制中的==服务器驱动协商==<br />例如：iso-8859-5,unicode-1-1;q=0.5 |
| Accept-Encoding     | string   | Accept-Encoding首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序 | 常见类型<br />1. gzip<br />2. compress<br />3. deflate<br />4. identity4 |
| Accept-Language     | string   | 客户端驱动协商，通过客户端驱动协商来告诉服务器需要返回何种语言的资源（中文、英文等） | zh-cn等                                                      |
| Authorization       | string   | 当页面进入后，请求返回401的状态码时，就需要客户端请求在Authorization中加入鉴权的请求，在收到含有Authorizatioon的请求后服务端会对token做特殊的饿操作，用于HTTP访问认证。 | Basic XXX(token)                                             |
| Expect              | String   | HTTP/1.1 用来扩展用户期望的字段，目前来讲是不怎么使用的      | 一个使用场景：<br />等到客户状态码100的相应客户端发送请求的时候需要指定Except: 100-continue |
| From                |          | 用来告诉服务期使用页面用户的电子邮箱地址，一般是用来显示来源渠道的，比如搜索引擎负责人的联系方式，做流量的变现 |                                                              |
| Host                |          | 通过Host来区别一台虚拟主机上的多个域名的应用，究竟应该打到哪儿, 通过HOST来区分，究竟是打到哪个域名中 |                                                              |
| If-Match            |          | 一般是用于缓存服务中，通过If-Match和ETag中的标志保持一直用于请求缓存的资源 | 形如If-xxx这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。<br />一般用于协商缓存 |
| If-Modified-Since   |          | 如果在If-Modified-Since字段指定的日期时间后，资源发生了更新，服务器会接受请求，如果没有匹配上这个条件就返回304，因为header中有条件没有满足要求 | 一般用于已经修改后的资源请求                                 |
| If-None-Match       |          | 和If-Match的作用相反                                         |                                                              |
| If-Range            |          | 如果If-Range和E-Tag的标识一致，就会范围资源Range指定范围的内容，否则就全部返回。 |                                                              |
| If-Unmodified-Since |          | 和If-Modified-Since作用相反                                  |                                                              |
| Max-Forwards        |          | 通过TRACE或OPTIONS方法，当Max-Forwards为0的时候，对应的服务器直接返回请求，否则就往下带并且Max-Forwards的数量-1 |                                                              |
| Proxy-Authorization |          | 用于给代理服务器鉴权。Authorization是给自己服务器鉴权的      |                                                              |
| Range               |          | 告诉只需获取部分资源的范围                                   |                                                              |
| Referer             |          | 告诉接收服务器原请求的地址在哪里                             |                                                              |
| User-Agent          |          | 告诉前端是什么浏览器，一般用来区分是否为移动端。             |                                                              |

### 6.5 响应首部字段

==服务器==用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息

| 字段名             | 字段类型       | 作用                                                         | 备注                                                         |
| ------------------ | -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Accept-Ranges      | bytes          | 范围请求的时候用于标注范围                                   |                                                              |
| Age                | number \| Date | 用于告诉源服务创建该请求到现在的时间                         |                                                              |
| ETag               | string         | 一串字符串，用于缓存服务器在相同url请求资源的时候告诉当前资源是否被更新的标识 | 1. 资源被缓存时，会由服务器给一个eTag的资源版本标识，这个完全由服务端进行控制<br />2. 强ETag和弱ETag：强ETag任何小的改变都会改变ETag，弱ETag只有根本性的发生改变才会改变（服务器行为）<br />3. 一般用于协商缓存的标识 |
| Location           | url（string）  | 将接收方引导至某个新的路由                                   | 1. 一般和3xx一起使用，告知重定向的路由地址                   |
| Proxy-Authenticate | string         | 将代理服务器所要求的认证信息发给客户端，后续请求代理服务器的时候带上对应的认证信息就行 |                                                              |
| Retry-After        | number         | 告知客户端多久之后再访问服务端的具体时间                     |                                                              |
| Server             | string         | 用于告知服务器的信息，例如apache的版本等                     |                                                              |
| Vary               | string         | 用于缓存信息的控制                                           | 用于告知缓存字段匹配新的信息，例如告诉Accept-Language就是从缓存中拿对应的Accept-Language相同的字段才会拿，否则就是重新向服务器发送请求拿到资源 |
| WWW-Authenticate   | string         | 用于告诉服务器鉴权的信息                                     | 客户端适用于访问请求URI所指定资源的认证方案（Basic或是Digest）和带参数提示的质询（challenge） |



### 6.6 实体首部字段

包含请求报文和响应报文中实体部分的首部信息，用于补充内容的更新时间等与实体相关的信息

| 字段名           | 类型   | 作用                                                         | 备注                                                         |
| ---------------- | ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Allow            | string | 告诉客户端，服务器能够接受的请求方法                         | GET/POST/OPTION/PUT等                                        |
| Content-Encoding | string | 客户端服务器对实体的主体部分选用的内容编码方式               | 常见类型<br />1. gzip<br />2. compress<br />3. deflate<br />4. identity4 |
| Content-Language | string | 告诉客户端，支持的语言                                       | Zh-CN等                                                      |
| Content-Length   | number | 文件的字节大小                                               |                                                              |
| Content-Location | string | 资源uri的位置                                                |                                                              |
| Content-MD5      | string | 将报文的内容经过md5和base64加密后塞入的，主要目的为防止报文内容被篡改，安全性的检查 |                                                              |
| Content-Range    | String | 请求时候请求部分的内容                                       | 例子：bytes:5001-10000/5000                                  |
| tExpires         | Date   | 源服务器会把资源过期的时间告诉代理服务器（缓存服务器），当时间超过的时候，缓存服务器需要从远端重新请求资源 | Expires: Sat Sep 04 2021 15:50:19 GMT                        |

### 6.7 Cookie相关的首部

**和cookie相关的首部**

Cookie：客户端请求带到服务端的cookie，通过cookie字段带过去

Set-Cookie: 服务端将cookie设置到浏览器，对应的cookie从Set-Cookie字段中带过去



**Set-Cookie中的属性**

1. NAME=VALUE：对应的需要设置的cookie
2. expires=Date: 对应cookie的过期时间
3. path=PATH：将服务器上的文件目录作为cookie的对象
4. domain：cookie可用的域名
5. Secure：只有在https的场景下才会设置cookie
6. httpOnly：加以限制，javascript无法操纵对应的cookie



### 6.8 其他首部

| 名称             | 类型   | 作用                                                         | 备注                                                         |
| ---------------- | ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| X-Frame-Options  | String | 用于控制网站内其他网页的Frame标签的现实问题，目的是为了防止劫持点击 | 所在位置：响应首部<br /><br />常见值：DENY，SAMEORIGIN<br /> |
| X-XSS-Protection | number | 用于控制浏览器XSS防护机制的开关                              | 所在位置：响应首部<br /><br />常见值：0: 将XSS过滤为无效状态<br />1. 将XSS过滤为有效状态<br /><br /> |
| DNT              | number | 用于拒绝个人信息被追踪                                       | 所在位置：响应首部<br /><br />常见值：0:同意被追踪<br />1. 拒绝被追踪<br /><br /> |
| P3P              |        | 利用P3P技术将web上的隐私变为可理解的形式，来保护用户的隐私<br /><br />**P3P header允许跨域访问隐私数据，从而可以跨域set-cookie成功** | 所在位置：响应首部<br />创建步骤：<br />1. 创建P3P隐私<br />2. P3P隐私对照文件后，保存在名为/w3c/p3p.html<br />3. 从P3P隐私中新建Compact policies后，输出到HTTP响应中 |

P3P可以跨域访问隐私信息，具体的方式可以参考：https://blog.csdn.net/kongdaoxian/article/details/7022294

## 7. 确保web安全的HTTPS

### 7.1 HTTP的缺点

1. 使用明文通信，内容可能会被窃听：所有的请求和响应都是以明文进行通信，没有加密的过程，不安全。
2. 不验证对方的身份，可能会遭遇伪装：请求发送的双方不会进行确认，导致客户端并不知道，响应是否真正由目标的主机返回。
3. 无法验证报文的完整性，有可能遭遇篡改：无法验证信息的完整度，即无法判断信息是否准确

#### 7.1.1 使用明文通信，内容可能会被窃听

如何被窃听：只需要通过抓包的方式就能获取通信的明文报文，从而获取请求内容

解决方式：加密

加密对象：

1. 通信的加密：通过SSL和TLS组合使用，加密HTTP的通信内容。通过SSL加密的通信链路为安全的通信链路，在上面进行的HTTP通信，称为HTTPS
2. 内容的加密：客户端需要对HTTP报文进行加密后再发送。服务端和客户端具有同时加密和解密的能力，但内容还是有被篡改的风险



#### 7.1.2 不验证对方的身份，可能会遭遇伪装

主要存在的问题：

1. 任何请求都会被返回：因为HTTP协议设计只要建立了连接就会返回
2. 无法判断客户端和服务端是否为目标的客户端和服务端，可能被伪造
3. 无法判断对方是否有访问的权限，例如伪造的请求来获取服务器上的内容
4. 无法阻止海量请求下的Dos攻击，导致服务器宕机

解决方式：CA证书

利用SSL的方式，在创立连接通路的时候，会先通过证书来确定使用双方的身份。通过证书可以确认通信方是目标的服务器，减少个人隐私的泄漏



#### 7.1.3 无法验证报文的完整性，有可能遭遇篡改

主要存在的问题：

1. 无法判断客户端发出的信息和服务端接受的信息是一致的，如果中间有攻击者劫持了信息进行发送，就可能产生意料之外的结果

解决方式：

通过SHA-1或MD5等散列值的校验方法，保证报文内容的一致性。

**Http header中的Content-MD5**



### 7.2 HTTP + 加密 + 认证 + 完整保护 = HTTPS

#### 7.2.1 HTTP加上加密处理和认证以及完整性保护后即是HTTPS

HTTPS解决的问题：通信过程的加密（加密处理） + 通信双方身份的确认（认证）

#### 7.2.2 HTTPS是身披SSL外壳的HTTP

HTTPS是将HTTP通信部分的协议通过SSL和TLS进行代替了，具体的部分如：

1. HTTP直接和TCP通信
2. HTTPS：HTTP先和SSL通信，之后SSL再和TCP通信

SSL本身是一个独立的协议，主要作用就是加密信道和身份认证，其他的SMTP和Telnet等协议也可以通过SSL夹持



#### 7.2.3 相互交换密钥的公开密钥加密技术

**现有的加密方式：**

+ 对称加密：都通过同一个公钥进行加密解密，但是这里公钥如何传递就是一个问题，容易被劫持，那就和不加密没区别了

+ 非对称加密：就是将公钥和私钥分开，公钥可以通过任意的形式传播，私钥存在服务器上，所有加密完的信息在服务端通过私钥进行解密
+ 混合加密（SSL采取的方式）：客户端先采取非堆成加密的方式通过公开的公钥请求对称加密的私钥，然后服务端验证没问题后返回对称加密的私钥，之后通过对称加密的方式进行加密传输

非对称加密的问题：公钥内容可能被篡改，导致加密信息一致无法被服务端解析，非对称加密的效率比较低

对称加密的问题：公共密钥保密发送比较难



#### 7.2.4 证明公开密钥正确性的证书

CA证书：由权威机构认证的能够证明公司服务端的公开密钥证书

申请步骤：

1. 服务器相关人员向权威认证机构提出申请，并提供公开密钥
2. 权威机构人员认证服务器相关人员身份后，对提供的公开密钥做数字签名
3. 将认证的公开密钥和证书绑定在一起



使用步骤：

1. 服务器将机构办法的证书发送给客户端
2. 客户端对证书上的数字签名进行验证，以保证证书的可靠性和公钥的有效性
3. 客户端发送公钥加密的报文到服务端
4. 服务端通过私钥进行报文的解密

![image-20210904181242254](/Users/pidan/Library/Application Support/typora-user-images/image-20210904181242254.png)



**openssl 和自有认证证书**

通过openssl每个人都可以自己颁布一个自己信任的证书，但是这样颁布的证书还是无法解决服务器身份认证的问题，所以会被浏览器认证为无效的证书。**值得信赖的第三方机构介入认证，才能让已植入在浏览器内的认证机构颁布的公开密钥发挥作用，并借此证明服务器的真实性。**



### 7.2.5 HTTPS的安全通信机制

**SSL通道建立的步骤**

![企业微信截图_3bac96a9-058b-42cd-992c-0482a536cb36](/Users/pidan/Library/Containers/com.tencent.WeWorkMac/Data/Library/Application Support/WXWork/Temp/ScreenCapture/企业微信截图_3bac96a9-058b-42cd-992c-0482a536cb36.png)

步骤：

1. 客户端通过发送ClientHello来开始SSL通信（报文中包含客户端支持的SSL版本、加密组件列表等信息）（第一次握手）
2. 服务器可以进行SSL通信时，通过返回Server Hello（响应的报文，并返回SSL版本和加密组件等信息）
3. 之后服务器发送Ceritificate报文，里面包含了公开的密钥
4. 最后服务器发送Server Hello Done（第一次握手阶段结束）
5. 客户端发起Client Key Exchange，报文中含==Pre-master secret==的随机密码串（客户端生成），报文通过公开（第二次握手开始）
6. 客户端发起报文Change Cipher Spec，报文会告诉服务端，后续用==Pre-master secret==的随机密码串作为对称加密密钥进行解析
7. 客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。（第二次握手结束）
8. 服务端同样发送Change Cipher Spec，确认对应的Pre-master secret
9. 服务端发送Finished报文
10. 完成上述步骤，SSL安全通信通道已经完成，后续的就发送HTTP请求进行通信
11. 应用层协议通信，即发送HTTP响应。
12. 客户端发送close_notify来结束通信
13. 关闭TCP连接

![企业微信截图_cdd9100f-6538-47ff-9eb2-8743f2625fc5](/Users/pidan/Library/Containers/com.tencent.WeWorkMac/Data/Library/Application Support/WXWork/Temp/ScreenCapture/企业微信截图_cdd9100f-6538-47ff-9eb2-8743f2625fc5.png)

**SSL和TLS**

HTTPS使用了SSL和TLS两个协议

SSL会降低通讯的效率，主要是因为：

1. **通信慢**（原因是除了TCP连接和发送HTTP请求外，还必须建立SSL通信通路）
2. **处理速度慢**（加密处理导致大量消耗CPU性能，导致处理速度变慢，因为在客户端和服务端都需要加密处理）



**为何不一致使用HTTPS**

1. 对于机器的处理器负载增加，处理请求的效率变低，所以一般敏感信息才需要通过HTTPS进行加密
2. 对于CA证书的认证有一定的花费，对于个人网站或者非敏感网站来说没有必要加密



## 8. 确认访问用户身份的认证

### 8.1 何为认证

核对身份信息通常的方式：

1. 密码：一般只有本人才会知道的字符串信息
2. 动态令牌：仅限本人持有的设备内的一次性密码
3. 数字认证：仅限本人持有的信息（一般是终端维度）
4. 生物认证：指纹虹膜等人的生理信息
5. IC卡：持有者本身的信息

上方的验证信息，**可以让计算机认为是出于个人行为发起的用户行为**



**HTTP/1.1的认证方式**

+ BASIC：基础认证
+ DIEGST：摘要认证
+ SSL：客户认证
+ FormBase：基于表单认证

### 8.2 BASIC认证

Basic基础认证步骤：

1. 当请求需要认证的Basic认证但未被认证时，发送的请求回应请求码为401，带WWW-Authenticate首部字段的响应。该字段内包含认证的方式（BASIC）及Request-URI安全域字符串（realm）。
2. 客户端需要将用户的登录信息（账号、密码）发送给服务器，两者间通过==：==进行连接，之后通过base64编码。(这里是直接将用户名和密码通过==：==隔开后直接base64加密之后通过Header中的Authorization Basic发送到后端)



缺点：

1. **不需要任何附加信息即可对其解码**。换言之，由于明文解码后就是用户ID和密码，在HTTP等非加密通信的线路上进行BASIC认证的过程中，如果被人窃听，被盗的可能性极高。
2. 用户登录无法被注销



### 8.3 DIEGST认证

采用了质询/响应的模式（challenge/response）

DIEGST认证步骤：

1. 服务器监测到用户没登录后，返回状态码设为401，在header中的WWW-Authenticate字段中发送一串随机数（nonce，一般由base64生成），和realm两个字段信息
2. 客户端收到401后，唤起用户登录，然后在发送的请求中增加Authorization字段，其中包括username, uri, nonce, realm, response 字段中是经过md5编码的密码的响应码
3. 客户端确认认证信息，认证成功返回中传的uri地址



缺点；

安全性还是没有达到目标，适用范围有限



### 8.4  SSL客户端认证

DIEGST和BASIC认证的问题，都是通过用户ID和密码的方式认证，如果用户的ID和密码丢失，那么可能会被第三者冒充登录



SSL客户端认证步骤：（通过客户端安装的证书来验证，所以客户端必须安装相应的证书）

1. 服务端收到请求，发送Certificate Request报文，请求客户端发送证书
2. 用户选择发送客户端的证书，把客户端证书信息通过Client Cerfiticate的报文发送给服务器
3. 服务器通过证书验证后可以通过证书内的客户端的公开密钥开始HTTPS加密通信



一般SSL客户端采用**双因素认证**，即账号密码（确认是正确的用户在通信） + 证书（确认是正确的客户端）

费用：目前客户端证书需要支付一定的费用才能使用，这个是客户端安装证书的费用，这个费用是从认证机构购买客户端证书的费用。



### 8.5 基于表单认证

基于表单的认证其实就是让用户通过账号密码进行登录的过程，web应用程序根据用户的id和密码的认证结果来判断是否认证成功

#### 8.5.1 认证多半为基于表单认证

现有认证的缺点：

1. BASIC和DIGEST：便利性和安全性存在问题
2. SSL：价格成本较高

> 不具备共同标准规范的表单认证，在每个Web网站上都会有各不相同的实现方式。如果是全面考虑过安全性能而实现的表单认证，那么就能够具备高度的安全等级。但在表单认证的实现中存在问题的Web网站也是屡见不鲜。



#### 8.5.2 Session 管理及Cookie的应用

![image-20210908134639289](/Users/pidan/Library/Application Support/typora-user-images/image-20210908134639289.png)

步骤： 

1. 客户端将用户ID和密码等登录信息发送报文到后端，通常用POST + HTTP
2. 服务器发放用以标识用户信息的Session ID，将客户端的登录信息进行身份认证完成session到用户信息的映射
3. 客户端收到session之后以cookie的方式保存在本地，下次请求的时候自动发送cookie，sessionid来实现登录的持久化



## 9. 基于HTTP的功能追加协议

### 9.1 基于HTTP的协议

因为现有的Web应用追求的功能基本都能通过现有的HTTP协议达成，但是可能性能上无法达到最优。一些新的协议在HTTP的现有功能上进行补齐

### 9.2 消除HTTP瓶颈的SPDY

SPDY的优势，解决HTTP性能瓶颈，缩短Web页面的加载时间

#### 9.2.1 HTTP的瓶颈

1. 一条连接上只可发送一个请求
2. 请求只能从客户端开始，客户端不接受除响应外的指令
3. 响应/请求首部未经压缩发送，首部信息过多造成的延迟
4. 每次发送相同的首部造成浪费较多
5. 发送数据格式非强制压缩发送



现有的优化方法：

1. ajax：请求后端接口，在不刷新页面的情况下局部更新页面内容
2. Comet：将请求先挂起，等到服务端内容更新再返回响应的响应（挂起请求维持链接，消耗过多的资源）



为什么SPDY：虽然Ajax和Comet等技术使HTTP的使用得到了一定的改善，但是他们都没有改变HTTP协议的基础，所以SPDY的协议为了解决HTTP协议存在的瓶颈



#### 9.2.2 SPDY的设计与功能

SPDY没有改写HTTP，而是在TCP/IP的应用和表示层之间增加了会话层，并且通信中也是使用SSL的协议

![image-20210909100344392](/Users/pidan/Library/Application Support/typora-user-images/image-20210909100344392.png)

使用SPDY后增加的功能：

1. 多路复用流：一次链接处理多个HTTP请求，减少多次创建HTTP通路的消耗
2. 赋予请求优先级：可以给多个请求分配优先级，解决因带宽低而响应变慢的问题
3. 压缩HTTP请求和响应首部
4. 推送：支持服务端向客户端推送数据的功能
5. 服务器提示功能，类似强制缓存，便于客户端直接获取缓存的内容，避免发起不必要的请求



#### 9.2.3 SPDY是否消除了Web的瓶颈

SPDY的确可以有效消除HTTP瓶颈的技术，但很多Web网站存在的问题并不是HTTP的瓶颈导致的。



### 9.3 使用浏览器进行全双工通信的WebSocket

#### 9.3.1 WebSocket的设计与功能

仍在开发中的WebSocket技术主要是为了解决Ajax和Comet里XMLHttpRequest附带的缺陷所引起的问题。

WebSocket是一个**独立的协议**，具体的API有W3C定为标准。



#### 9.3.2 WebSocket协议

一旦WebSocket服务器与客户端之间建立起了WebSocket协议的通信连接，后续所有的通信都依靠这个专用协议进行。其过程中可以互相发送JSON、XML、HTML或图片等任意格式的数据

一旦确立WebSocket通信连接，无论是服务器还是客户端，都可以向对方发送报文，即双工

主要特点：

1. 支持推送功能
2. 减少通信量：原因是在建立通信链路的时候已经保持了连接状态，减少了每次通信连接的开销



WebSocket的握手请求：

1. 使用HTTP的Upgrade首部字段，设置为websocket告诉服务器通信协议发生改变
2. Sec-WebSocket：记录在WebSocket通信过程中使用的子协议（主要用于在断开连接的时候，定义连接的名称用的）



WebSocket响应：

1. 返回状态码101代表协议的转黄
2. Sec-WebSocket-Accept：透传之前的Sec-WebSocket
3. Sec-WebSocket-Protocol: 子协议的类型

**当握手成功，建立WebSocket连接后，通信时不再使用HTTP的数据帧，采用WebSocket独立的数据帧**

![image-20210909133554104](/Users/pidan/Library/Application Support/typora-user-images/image-20210909133554104.png)



目前可以通过浏览器自带的WebSocket的API实现对WebSocket的服务器建立WebSocket连接



### 9.4 期盼已久的HTTP/2.0

正在讨论的技术：

+ 多路复用
+ TLS义务化
+ 协商
+ 客户端拉拽/服务器推送
+ 流量控制
+ WebSocket



### 9.5 Web服务器管理文件的WebDAV

WebDAV是一个可对Web服务器上的内容进行文件复制、编辑、删除、版本控制、加锁等操作的分布式文件系统

HTTP虽然提供了PUT和DELETE对文件系统进行创建和删除操作，但是由于安全性，一般不使用



#### 9.5.1 协议概念的扩展

协议概念的扩展：

1. 集合：是一种统一管理多个资源的概念
2. 资源：把文件和集合统一称为资源
3. 属性：资源本身的属性，比如名称时间等，key=value的形式保存
4. 锁：文件设置成无法编辑的状态



#### 9.5.2 状态码和方法的扩展

协议HTTP Method的扩展：

1. PROPFIND：获取属性
2. PROPPATCH：修改属性
3. MKCOL：创建集合
4. COPY：复制资源属性
5. MOVE：移动资源
6. LOCK：资源加锁
7. UNLOCK：资源解锁



状态码的扩展

1. 102: 可正常处理请求，但是目前是处理中
2. 207:存在多种状态
3. 422:格式正确，内容有误
4. 423:已加锁
5. 424:请求失败
6. 507:保存空间不足



## 10. 构建Web内容的技术

### 10.1 HTML

主要讲了HTML和CSS，略

### 10.2 动态HTML

主要讲了DOM和javascript，略

### 10.3 Web应用

#### 10.3.1 通过Web提供功能的Web应用

Web应用是指通过Web功能提供的应用程序。

HTTP协议本身就是为了对客户端的请求，返回实现准备好的内容

目前静态的HTML内容难以满足现代人的需要，然后通过程序可以通过HTTP的请求动态创建HTML来满足日益复杂的场景需求。

#### 10.3.2 与Web服务器及程序写作的CGI

CGI（通用网关接口）：是指Web服务器在接收到客户端发送过来的请求后转发给程序的一组机制

CGI的劣势：每次接到请求就需要重启一次，开销过大。

#### 10.3.3 因Java而普及的Servlet

Servlet是一种能在服务器上创建创建内容的程序。Servlet是Java语言实现的接口，其运行的容器叫做Web容器或者Servlert容器

Servlet运行在与Web服务器相同的进程中，因此受到的负载较小

### 10.4 数据发布的格式语言

HTML：超文本标记语言，略

XML：可以自定义标签，相比HTML更容易读取数据，通过标签分割的树结构，更容易对数据进行读取

RSS/ATOM：都用到了XML，发布新闻或者文档的固定格式

JSON：以javascript中的对象为基础的轻量级标记语言，包括：false/null/true/对象/数字/字符串/数组其中类型



## 11. Web的攻击技术

### 11.1 针对Web的攻击技术

HTTP是一个通用的单纯的协议机制，在安全性方面呈劣势，而每个Web应用都需要自己设计认证、鉴权、会话、管理的方式，但是并没有统一的规范，这样就容易被攻击者滥用攻击系统认证的bug



面对这类问题建议解决的办法：

1. **输入检查**
2. **输出转译**

#### 11.1.2 客户端篡改需求

通过URL查询表单字段、HTTP首部或者Cookie等途径植入恶意代码，窃取用户信息或权限

#### 11.1.3 针对web应用的攻击模式

主要类别：

1. 主动攻击：主动传入代码传入的攻击的模式
2. 被动攻击：指利用圈套策略执行攻击代码的攻击模式，攻击者不主动向服务器进行攻击



常见的**主动攻击**：

1. SQL注入：运用查询时的sql，来越权拉取数据库的数据
2. OS命令注入攻击：利用服务器执行系统命令，来使服务器崩溃



常见的**被动攻击**模式：邮件恶意网站等



**被动攻击**的攻击模式步骤如下：

1. 攻击者诱导用户进入陷阱，一旦触发陷阱，陷阱会自动发送已经嵌入恶意脚本的HTTP请求
2. 客户的邮件和浏览器出发陷阱
3. 出发陷阱发送对应含有恶意代码的HTTP请求，进行攻击
4. 恶意劫持了用户的Cookie信息，用户的登录信息等



被动攻击除了用户信息被泄露外，还可以对企业内网进行攻击，如果这个用户是企业内部人员，还可以拿到企业内部员工的登陆态，从而发起攻击。



### 11.2 因输出值转译不完全导致的漏洞

Web的安全策略：

1. 浏览器（客户端）校验：输入值校验，输出值转译
2. 服务端校验

#### 11.2.1 跨站脚本攻击（XSS）

通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。**利用预先设计好的陷阱进行攻击的被动攻击方式**

【例子】动态生成html的时候，比如v-html或者dangerousInnerHtml, innerHTML进行插入的时候，这个时候如果用户输入一个html字符串，比如一个script标签里面有了恶意代码，这个时候就会在用户进入时截取用户信息

造成影响：

1. 利用虚假输入表单骗取用户个人信息，窃取用户的cookie（往页面中植入一个虚假表单）
2. 显示伪造的图片



#### 11.2.2 SQL注入攻击

SQL注入：如果SQL语言处理不当，例如直接将HTTP请求传过来的参数拼接到SQL中执行，可能被执行恶意的注入的SQL语句，

【例如】通过 --来注释掉查询sql中其他的查询条件，导致非法查询数据库中的数据

造成的结果：

1. 非法查看篡改数据库中的数据
2. 规避认证
3. 执行数据库和服务器相关的程序



#### 11.2.3 OS命令注入攻击

OS命令注入：通过Web应用，执行非法的操作系统命令达到攻击的目的，如果在调用Shell的时候出现漏洞的话也可能被攻击

比如，通过；来间断bash命令，后面就是可以读取服务器env中的密码变量等信息，进行窃取



#### 11.2.4  HTTP首部注入攻击

HTTP首部注入攻击：在响应头中插入换行，添加任意响应首部或者主体的一种攻击方式

主要篡改：

1. Cookie信息
2. 重定向至某个URL
3. 显示任意主体信息（HTTP响应截断攻击）



**1. 篡改Cookie信息**

通过篡改Set-Cookie的方式，来修改用户信息进行操作

**2. HTTP响应截断攻击**

通过注入连续两个换行符，来模拟请求中的响应体，这样就可以插入攻击者自己的自定义页面，来实现被动攻击



#### 11.2.5 邮件首部注入攻击

主要是通过向邮件首部中的To或Subject，这样可以向任意的邮件地址发送广告邮件或病毒邮件



#### 11.2.6 目录遍历攻击

目录遍历攻击：本无意公开的目录通过非法截断路径的形式，达成访问目的的一种攻击方式，也称路径遍历攻击（Path Traversal）

应该关闭文件夹的访问权限，来解决本不可被公开的文件被访问的隐患



#### 11.2.7 远程文件包含漏洞

远程文件包含漏洞：是指当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的URL充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击

主要是php，因为include可以引入外部的网址，所以可以通过include进入钓鱼网页



### 11.3 因设置或设计上的缺陷引发的安全漏洞

#### 11.3.1 强制浏览

强制预览：将非公开资源放在公共资源文件下，导致非公开资源被随意浏览。比如：查看图片的目录为xxxx.com/img/xxxxx.jpg，那么只要知道这个url的路径，就可以随意预览对应页面下的jpg

**解决办法：**通过后缀或者白名单的形式，在请求资源的时候进行校验，对非公开的资源不进行访问，必须经过认证的文件才能进行访问



#### 11.3.2 不正确的错误消息处理

Web应用抛出的错误可能会被攻击者加以利用，Web应用不必在请求或者页面中展示对应的Web应用层面的异常信息。

主要常见的错误：

1. 应用抛出的错误，错误提示范围过小，导致信息被利用。登录失败提示【认证错误】优于 【不存在该用户/用户密码验证错误】，**后者可能会让别人判读到这个用户已经存在**
2. 数据库抛出的错误，数据库的报错信息中有时候含有SQL语句报错，如果抛出在页面上可能会泄露【数据库的相关信息】和【表的相关字段】，如果对外暴露可能会泄露数据库字段相关信息，被攻击者利用



#### 11.3.3 开放重定向

开放重定向指的是类似，xxx.com?redirect=yyy.cn, 就是通过参数任意重定向，这样的话用户可能会被引导至任意的恶意网站，很有可能被当作钓鱼网站的踏板



### 11.4 因为会话管理疏忽导致的安全漏洞

如果是通过session来判断用户登陆态的话，如果session被人拿到，可能会用来伪装用户

攻击者获取会话id的方式：

1. 通过非正规生成方法获取，比如没有通过md5加密等，可能就是明文
2. 通过XSS漏洞窃取对应的会话id（一般通过document.cookie注入恶意脚本来获取cookie）
3. 通过会话固定攻击，强行获取会话id

#### 11.4.1 会话劫持

会话劫持（session hijack）：指的是在url上通过带sid的方式，可能会让攻击者通过url中带的sid，伪装用户达到攻击目的

【例子】xxxxx?sid=xxxx，可以通过抓包直接获取用户的sid，进而伪装用户

#### 11.4.2 会话固定攻击

【场景】：根据登录页面生成sid，引导真用户登录，真用户登录后，因为该sid有效了，所以直接通过sid就可以冒充用户进行登录

固定指的是：sid随机生成后，就不变，等待被激活

#### 11.4.3 跨站点伪造请求（CSRF）

CSRF指的是：攻击者通过已设置好的陷阱，让已登录的用户做一些已经埋入脚本的非用户预期的操作，比如更改用户信息，或者更改展示信息等。

【简单理解】**攻击者盗用了你的身份，以你的名义发送恶意请求**

CSRF漏洞操作的流程：

1. 已经登录了目标网站A，有A网站的登陆态
2. 不小心进入了恶意网站B
3. 恶意网站B中有引用了一个向网站A做用户操作的请求C
4. 这个时候C中带有A的登陆态，所以可以执行用户操作、

### 11.5 其他漏洞

#### 11.5.1 密码破解

可以通过算出或者穷举出密码的形式进行密码的破解，突破认证。

主要方法：

1. 穷举法
2. 字典法：通过可能的密码排列组合进行破解，相比穷举法可能会更高效
3. 穷举法 + 字典法进行攻击
4. 获取加密密码解析办法
   1. 获取彩虹表（对照出结果）
   2. 拿到密钥（反解密）
   3. 加密算法本身的漏洞



#### 11.5.2 点击劫持

用透明层覆盖页面，然后将对应的点击事件绑定到页面实际元素上的点击事件，这样的话就可以间接向对应的按钮发送事件，做出非预期的操作



#### 11.5.3 Dos攻击

Dos攻击：让原来运行中的服务呈停止状态的攻击

**攻击方式**：

1. 利用访问请求造成资源过载，资源过载的同时，服务器也终止了（大量发送合法请求，让服务端崩溃）
2. 通过攻击安全漏洞使服务停止，比如Web应用的BUG

多台计算机一起发起Dos攻击称为DDos



#### 11.5.4 后门程序

后门程序：开发自己设置的隐藏入口，可以不受限制，比如跳过登录，直接查询后台数据等。

一般的后门程序：

1. 开发用于DEBUG的
2. 开发为了自身利益植入的
3. 攻击者通过某种方式设置的































































